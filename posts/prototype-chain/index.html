<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>JS | 原型链的理解 - Falasool</title><link rel=icon type=image/png href=static/img/favicon.png><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="先上图 一些概念 JS 中万物皆对象，分为普通对象和函数对象。 每个对象都有一个私有属性 [[Prototype]] ，私有属性指向原型 prototype，由于原型 prototype 也是对象，它"><meta property="og:image" content><meta property="og:title" content="JS | 原型链的理解"><meta property="og:description" content="先上图 一些概念 JS 中万物皆对象，分为普通对象和函数对象。 每个对象都有一个私有属性 [[Prototype]] ，私有属性指向原型 prototype，由于原型 prototype 也是对象，它"><meta property="og:type" content="article"><meta property="og:url" content="https://falasool.github.io/posts/prototype-chain/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-02T19:41:35+08:00"><meta property="article:modified_time" content="2024-04-02T19:41:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="JS | 原型链的理解"><meta name=twitter:description content="先上图 一些概念 JS 中万物皆对象，分为普通对象和函数对象。 每个对象都有一个私有属性 [[Prototype]] ，私有属性指向原型 prototype，由于原型 prototype 也是对象，它"><script src=https://falasool.github.io/js/feather.min.js></script>
<link href=https://falasool.github.io/css/fonts.4bacf4386d3f58fdc378d205a903311c80158bf414d25698589b658e0273156d.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://falasool.github.io/css/main.409b4163748cd4906669e4c6d5a0483433fd78fba4753a71f4d1748dbc962736.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://falasool.github.io/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css media="(prefers-color-scheme: dark)"></head><body><div class=content><header><div class=main><a href=https://falasool.github.io/>Falasool</a></div><nav><a href=/friends/></a>
<a href=/about>About</a>
<a href=/friends>Friends</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>JS | 原型链的理解</h1><div class=meta>Posted on Apr 2, 2024</div></div><section class=body><p><img src=https://cdn.jsdelivr.net/gh/Falasool/blog-pic-bed@main/blog202404101944461.jpg alt=951712748932_.pic_hd></p><p>先上图</p><h2 id=一些概念>一些概念</h2><p>JS 中万物皆对象，分为普通对象和函数对象。</p><p>每个对象都有一个私有属性 <code>[[Prototype]]</code> ，私有属性指向原型 prototype，由于原型 prototype 也是对象，它会重复这一循环层层向上，直到一个对象的原型为 null</p><p><code>__proto__</code> 是 <code>[[Prototype]]</code> 的 getter/setter</p><p><code>__proto__</code> 的 value 必须是对象/null</p><p>原型链不能形成闭环</p><h2 id=普通的原型链>普通的原型链</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Parent</span>()
</span></span></code></pre></div><p>我声明了一个对象 p，p作为Parent的实例，能拿到Parent里预先定义的属性和方法，这就是继承</p><p><code>p.__proto__ === Parent.prototype</code> ，<code>__proto__</code> 像指针，指向实例继承的属性&方法</p><p><code>Parent.prototype.constructor === Parent</code>，<code>Parent.prototype</code>本身是Parent 的一个实例，反过来说， <code>Parent.prototype</code>的构造器是Parent</p><p>图中的虚线，p =====> Parent，因为<code>p.constructor</code>实际上是从<code>Parent.prototype</code>继承来的⬆️</p><h2 id=js-中的-function-和-object>JS 中的 Function 和 Object</h2><p>设计思想：高内聚、低耦合</p><ul><li>Function的constructor是Function，所以<code>Function.__proto__</code> 指向 <code>Function.prototype</code></li><li>Object的constructor是Function</li></ul><p>盘古开天地：先有 <code>Object.prototype</code> ，再有 <code>Function.prototype</code> ，再有 Function 和Object</p><blockquote><p>当我们说一个对象继承自某个 Constructor 时，其实我们是在说，从这个对象的原型链上找到了 Constructor.prototype。</p><p>所以，Object.prototype 可以先于 Object 出现，然后用这个 prototype 构造出 Function.prototype，有了 Function.prototype 再构造出 Function ， Object 这几个构造器。然后把 Object.prototype 挂到 Object 上，Function.prototype 挂到Function 上。</p><p>好比栗子中的 obj 构造自 p ，而 obj 构造出来之后，p 才挂到 A 上，我们说 obj 是 A 类型的，但是 obj 是用 A.prototype(就是 p ) 构造出来的。</p><p>分析可得：全局下的 Object 构造自 Function.prototype， Function.prototype 构造自 Object.prototype。</p></blockquote><h2 id=联系>联系</h2><p><code>instanceof</code> 的原理：原型链（遍历目标的原型链，直到找到右边变量的 prototype）</p><p>特殊情况：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Function <span style=color:#66d9ef>instanceof</span> Object) <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(Object <span style=color:#66d9ef>instanceof</span> Function) <span style=color:#75715e>// true
</span></span></span></code></pre></div><p>Object的构造器是 Function，同时 JS 中万物皆对象💦</p><h2 id=参考--致谢>参考 & 致谢</h2><p><a href=https://segmentfault.com/a/1190000021232132>javascript - 一张图搞定JS原型&原型链 - 个人文章 - SegmentFault 思否</a></p><p><a href=https://zhuanlan.zhihu.com/p/84876191>从面向对象设计角度，全面解读——JS中的函数与对象、Object与Function、以及原型链与继承 - 知乎</a></p><p><a href=https://juejin.cn/post/7057544558057357348>js中先有Function，还是先有Object？ - 掘金</a></p><p><a href=https://segmentfault.com/a/1190000042363833>深入理解JavaScript——Object（对象） - 个人文章 - SegmentFault 思否</a></p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/javascript>Javascript</a></li><li><a href=/tags/tech>tech</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/falasool/ rel=me title=GitHub><i data-feather=github></i></a><a class=soc href=https://gitlab.com/athul/ rel=me title=GitLab><i data-feather=gitlab></i></a></div><div class=footer-info>2025 © Falaool<br>Built with <a href=https://gohugo.io>Hugo</a> & Theme <a href=https://github.com/athul/archie>Archie</a> design by Athul</div></footer><script>feather.replace()</script></div></body></html>